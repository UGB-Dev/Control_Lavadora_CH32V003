/*

    OLED_SSD1306.c

*/

#include "OLED_SSD1306.h"

uint8_t Buffer[128*8] = {0};

const uint8_t Config_OLED[] = {
    0xAE, // Display apagado
    0xA8, 0x3F, // Ajuste de multiplex (HEIGHT-1): 0x1F para 128x32, 0x3F para 128x64
    0xD3, 0x00, // Display offset a 0
    0x40, // Ajuste de linea de inicio en el display a 0
    0x8D, 0x14, // Ajuste para habilitar la bomba de carga
    0x20, 0x00, // Direccion de memoria horizontal (0x00)
    0xDA, 0x12, // Configuracion secuancial para COM; ajuste de 8 com 0x12 y salteado en 0x02
    0x81, 0x0F, // Ajuste de contraste con un valor de 0x80
    0xD6, 0x00, // Ajuste de zoom deshabilitado 0x00 y 0x01 para habilitar; con 0x12 en registro 0xDA
    0xD9, 0xF1, // Ajuste del periodo de precarga
    0xDB, 0x40, // Ajuste de deteccion de vcom
    0x22, 0x00, 0x07, // Ajuste de pagina min a max
    0x21, 0x00, 0x7F, // Ajuste de Columna min a max
    0xAF // Display on
};

const uint8_t OLED_FONT[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //   0
    0x00, 0x00, 0x2f, 0x00, 0x00, 0x00, // ! 1
    0x00, 0x07, 0x00, 0x07, 0x00, 0x00, // " 2
    0x14, 0x7f, 0x14, 0x7f, 0x14, 0x00, // # 3
    0x24, 0x2a, 0x7f, 0x2a, 0x12, 0x00, // $ 4
    0x62, 0x64, 0x08, 0x13, 0x23, 0x00, // % 5
    0x36, 0x49, 0x55, 0x22, 0x50, 0x00, // & 6
    0x00, 0x05, 0x03, 0x00, 0x00, 0x00, // ' 7
    0x00, 0x1c, 0x22, 0x41, 0x00, 0x00, // ( 8
    0x00, 0x41, 0x22, 0x1c, 0x00, 0x00, // ) 9
    0x14, 0x08, 0x3E, 0x08, 0x14, 0x00, // * 10
    0x08, 0x08, 0x3E, 0x08, 0x08, 0x00, // + 11
    0x00, 0x00, 0xA0, 0x60, 0x00, 0x00, // , 12
    0x08, 0x08, 0x08, 0x08, 0x08, 0x00, // - 13
    0x00, 0x60, 0x60, 0x00, 0x00, 0x00, // . 14
    0x20, 0x10, 0x08, 0x04, 0x02, 0x00, // / 15
    0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00, // 0 16
    0x00, 0x42, 0x7F, 0x40, 0x00, 0x00, // 1 17
    0x42, 0x61, 0x51, 0x49, 0x46, 0x00, // 2 18
    0x21, 0x41, 0x45, 0x4B, 0x31, 0x00, // 3 19
    0x18, 0x14, 0x12, 0x7F, 0x10, 0x00, // 4 20
    0x27, 0x45, 0x45, 0x45, 0x39, 0x00, // 5 21
    0x3C, 0x4A, 0x49, 0x49, 0x30, 0x00, // 6 22
    0x01, 0x71, 0x09, 0x05, 0x03, 0x00, // 7 23
    0x36, 0x49, 0x49, 0x49, 0x36, 0x00, // 8 24
    0x06, 0x49, 0x49, 0x29, 0x1E, 0x00, // 9 25
    0x00, 0x36, 0x36, 0x00, 0x00, 0x00, // : 26
    0x00, 0x56, 0x36, 0x00, 0x00, 0x00, // ; 27
    0x08, 0x14, 0x22, 0x41, 0x00, 0x00, // < 28
    0x14, 0x14, 0x14, 0x14, 0x14, 0x00, // = 29
    0x00, 0x41, 0x22, 0x14, 0x08, 0x00, // > 30
    0x02, 0x01, 0x51, 0x09, 0x06, 0x00, // ? 31
    0x32, 0x49, 0x59, 0x51, 0x3E, 0x00, // @ 32
    0x7C, 0x12, 0x11, 0x12, 0x7C, 0x00, // A 33
    0x7F, 0x49, 0x49, 0x49, 0x36, 0x00, // B 34
    0x3E, 0x41, 0x41, 0x41, 0x22, 0x00, // C 35
    0x7F, 0x41, 0x41, 0x22, 0x1C, 0x00, // D 36
    0x7F, 0x49, 0x49, 0x49, 0x41, 0x00, // E 37
    0x7F, 0x09, 0x09, 0x09, 0x01, 0x00, // F 38
    0x3E, 0x41, 0x49, 0x49, 0x7A, 0x00, // G 39
    0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00, // H 40
    0x00, 0x41, 0x7F, 0x41, 0x00, 0x00, // I 41
    0x20, 0x40, 0x41, 0x3F, 0x01, 0x00, // J 42
    0x7F, 0x08, 0x14, 0x22, 0x41, 0x00, // K 43
    0x7F, 0x40, 0x40, 0x40, 0x40, 0x00, // L 44
    0x7F, 0x02, 0x0C, 0x02, 0x7F, 0x00, // M 45
    0x7F, 0x04, 0x08, 0x10, 0x7F, 0x00, // N 46
    0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00, // O 47
    0x7F, 0x09, 0x09, 0x09, 0x06, 0x00, // P 48
    0x3E, 0x41, 0x51, 0x21, 0x5E, 0x00, // Q 49
    0x7F, 0x09, 0x19, 0x29, 0x46, 0x00, // R 50
    0x46, 0x49, 0x49, 0x49, 0x31, 0x00, // S 51
    0x01, 0x01, 0x7F, 0x01, 0x01, 0x00, // T 52
    0x3F, 0x40, 0x40, 0x40, 0x3F, 0x00, // U 53
    0x1F, 0x20, 0x40, 0x20, 0x1F, 0x00, // V 54
    0x3F, 0x40, 0x38, 0x40, 0x3F, 0x00, // W 55
    0x63, 0x14, 0x08, 0x14, 0x63, 0x00, // X 56
    0x07, 0x08, 0x70, 0x08, 0x07, 0x00, // Y 57
    0x61, 0x51, 0x49, 0x45, 0x43, 0x00, // Z 58
    0x00, 0x7F, 0x41, 0x41, 0x00, 0x00, // [ 59
    0x02, 0x04, 0x08, 0x10, 0x20, 0x00, // \ 60
    0x00, 0x41, 0x41, 0x7F, 0x00, 0x00, // ] 61
    0x04, 0x02, 0x01, 0x02, 0x04, 0x00, // ^ 62
    0x40, 0x40, 0x40, 0x40, 0x40, 0x00, // _ 63
    0x0E, 0x1E, 0x3C, 0x3C, 0x1E, 0x0E
};

///////////////////////////////////////////////////////////////////
//////////  FUNCIONES PARA ENVIAR DATOS O COMANDOS  ///////////////

void Dato_(void){
    Inicio_Trama();
    I2C_SOFT_Enviar(0x78); // Se envia direccion + escritura (0x78)
    I2C_SOFT_Enviar(0x40); // Se envia 0x40 para datos
}

void Comando_(void){
    Inicio_Trama();
    I2C_SOFT_Enviar(0x78); // Se envia direccion + escritura (0x78)
    I2C_SOFT_Enviar(0x00); // Se envia 0x00 para comandos
}

///////////////////////////////////////////////////////////////////
/////////////  FUNCIONES PARA CONTROLAR EL DISPLAY  ///////////////

void OLED_Init(void){
    for(uint8_t i=0; i<27; i++){ // Se envian 27 registros de configuracion
        Comando_(); // Inicio de trama para enviar comandos al OLED
        I2C_SOFT_Enviar(Config_OLED[i]); 
        Fin_Trama(); 
    }
}

void OLED_Clear(void){
    for (uint16_t i=0; i<1024; i++){ Buffer[i] = 0; } // Limpia el contenido del buffer
}

void OLED_Print_Pixel(int16_t Pos_x, int16_t Pos_y){
    if ((Pos_x < Width && Pos_x >= 0) && (Pos_y < Height && Pos_y >= 0)) {
        Buffer[Pos_x + (((Pos_y>>3) & 0x7) << 7)] |= 1<<(Pos_y%8);
    }
}

void OLED_Print_Buffer(void){ 
    Dato_(); 
    for(uint16_t i=0; i < 1024; i++){ // Se envia el contenido del buffer
        I2C_SOFT_Enviar(Buffer[i]);   
    }
    Fin_Trama(); 
}

void OLED_Linea(uint8_t X0, uint8_t Y0, uint8_t X1, uint8_t Y1 ){
    int dx = abs(X1-X0);
    int dy = -abs(Y1-Y0);
    int sx = (X0 < X1)? 1 : -1;
    int sy = (Y0 < Y1)? 1 : -1;
    int err = dx + dy;

    while (1) {
        OLED_Print_Pixel(X0, Y0);
        if (X0 == X1  && Y0 == Y1) break;
        int e2 = 2 * err;
        if(e2 >= dy){ err += dy; X0 += sx; }
        if(e2 <= dx){ err += dx; Y0 += sy; }
    }
}

void OLED_Cuadrado(uint8_t X0, uint8_t Y0, uint8_t LadoX, uint8_t LadoY){
    OLED_Linea(X0, Y0, X0+LadoX, Y0);
    OLED_Linea(X0, Y0, X0, Y0+LadoY);
    OLED_Linea(X0+LadoX, Y0, X0+LadoX, Y0+LadoY);
    OLED_Linea(X0, Y0+LadoY, X0+LadoX, Y0+LadoY);
}

void OLED_Print_Str(uint8_t xpos, uint8_t ypos, const char* DATA){
    while(*DATA!=0){ // Ciclo infinito si el dato es diferente de 0
        for (uint8_t i=0; i<6; i++){ 
            Buffer[xpos++ + ((ypos>>3) << 7)] = OLED_FONT[(*DATA-32)*6 + i];
        }
        DATA++; // Incrementa a la siguiente posicion del string
    }
}
void OLED_Print_Char(uint8_t xpos, uint8_t ypos, char DATA){
    for (uint8_t i=0; i<6; i++){ 
        Buffer[xpos++ + ((ypos>>3) << 7)] = OLED_FONT[(DATA-32)*6 + i];
    }
}